/*
 * EMICPWrapper.h
 *
 *  Created on: 22.02.2012
 *      Author: kfritscher
 */

#ifndef EMICPWRAPPER_H_
#define EMICPWRAPPER_H_

#include "itkTransform.h"
#include "itkMatrix.h"
#include "vtkPolyData.h"

#include "3dregistration.h"

#include "itkScalableAffineTransform.h"
#include "itkPointSet.h"
#include "vtkPoints.h"
#include "itkDefaultStaticMeshTraits.h"
#include "vtkSmartPointer.h"
#include "3dregistration.h"
#include "vtkIterativeClosestPointTransform.h"
#include "vtkLandmarkTransform.h"
#include "vtkMath.h"
#include "vtkMatrix4x4.h"

namespace ibia
{

class ICPWrapper
{

  vtkSmartPointer<vtkIterativeClosestPointTransform> m_ICPVTK;

  int m_NumPointsRef;
  int m_NumPointsCand;

  registrationParameters m_Parameters;


public:

  typedef itk::ScalableAffineTransform<double,3> TransformType;
  typedef TransformType::MatrixType MatrixType;
  typedef TransformType::OffsetType OffsetType;

  ICPWrapper();

  void PointsReduction(float **X, int &Xsize,float random_sampling_percentage, bool initialize_rand = true);

  void doRegistration(vtkSmartPointer<vtkPolyData> reference,vtkSmartPointer<vtkPolyData> candidate,unsigned int percentRef=100,unsigned int percentCand=100,bool useemicp=true);
  TransformType::Pointer GetFinalTransform();



  void SetRegistrationParameters(registrationParameters para)
  {
    m_Parameters.sigma_p2=para.sigma_p2;
    m_Parameters.sigma_inf=para.sigma_inf;
    m_Parameters.sigma_factor=para.sigma_factor;
    m_Parameters.d_02=para.d_02;
    //m_Parameters.noviewer=para.noviewer;
  }

  void SetViewer(bool viewer)
  {
      m_Parameters.noviewer=!viewer;
  }

  virtual
  ~ICPWrapper();

private:
  MatrixType m_ResultMatrixITK;
  OffsetType m_ResultOffsetITK;
  TransformType::Pointer m_FinalTransform;

//  void InitPointCloud(const float* h_X, const int Xsize,
//                      const float* h_Y, const int Ysize,
//                      float* &points1, float* &points2, float* &points3)
//  {

//    const float* h_Xx = &h_X[Xsize*0];
//    const float* h_Xy = &h_X[Xsize*1];
//    const float* h_Xz = &h_X[Xsize*2];

//    const float* h_Yx = &h_Y[Ysize*0];
//    const float* h_Yy = &h_Y[Ysize*1];
//    const float* h_Yz = &h_Y[Ysize*2];

//    // Generate a random point cloud:
//    points1 = new float[Xsize*3];
//    for (int i=0; i<Xsize; i++)
//      {
//        float* point = &points1[i*3];
//        point[0] = h_Xx[i];
//        point[1] = h_Xy[i];
//        point[2] = h_Xz[i];
//      }
//    // Inform the engine about the first point cloud ("index" 0)...
////    EnginePointCloudData(0, points1, Xsize);
//    // ... and some fancy attributes like color and point size.
////    EnginePointCloudDecoration(0, 1.0f, 1.0f, 0.0f, 2.0f);

//    // Another point cloud:
//    points2 = new float[Ysize*3];
//    for (int i=0; i<Ysize; i++)
//      {
//        float* point = &points2[i*3];
//        point[0] = h_Yx[i];
//        point[1] = h_Yy[i];
//        point[2] = h_Yz[i];
//      }
////    // The second point cloud has "index" 1.
////    EnginePointCloudData(1, points2, Ysize);
////    EnginePointCloudDecoration(1, 0.0f, 1.0f, 1.0f, 2.0f);


//  #if 1

//    // third point cloud:
//    points3 = new float[Ysize*3];
//    for (int i=0; i<Ysize; i++)
//      {
//        float* point = &points3[i*3];
//        point[0] = h_Yx[i];
//        point[1] = h_Yy[i];
//        point[2] = h_Yz[i];
//      }

////    EnginePointCloudData(2, points3, Ysize);
////    EnginePointCloudDecoration(2, 1.0f, 1.0f, 1.0f, 2.0f);

//  #endif

//  }

  void init_RT(float *h_R, float *h_t);

};

} /* namespace ibia */
#endif /* EMICPWRAPPER_H_ */
